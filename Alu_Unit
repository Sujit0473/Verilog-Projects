// alu.v
`timescale 1ns / 1ps
module alu(
    input [31:0] src1,
    input [31:0] src2,
    input [5:0] alu_control,
    input [31:0] imm_val_r,
    input [4:0] shamt,
    output reg [31:0] result
);

    always @(*) begin
        case (alu_control)
            6'b000001: result = src1 + src2; // add
            6'b000010: result = src1 - src2; // sub
            6'b000011: result = src1 << src2; // sll
            6'b000100: result = (src1 < src2) ? 1 : 0; // slt
            6'b000101: result = ($unsigned(src1) < $unsigned(src2)) ? 1 : 0; // sltu
            6'b000110: result = src1 ^ src2; // xor
            6'b000111: result = src1 >> src2; // srl
            6'b001000: result = $signed(src1) >>> src2; // sra
            6'b001001: result = src1 | src2; // or
            6'b001010: result = src1 & src2; // and

            6'b001011: result = src1 + imm_val_r; // add immediate
            6'b001100: result = imm_val_r << shamt; // slli
            6'b001101: result = (imm_val_r < src1) ? 1 : 0; // slti
            6'b001110: result = src1 & src2; // sltiu (check if correct)
            6'b001111: result = src1 ^ imm_val_r; // xori

            6'b010000: result = src1 >> imm_val_r[4:0]; // srli
            6'b010001: result = src1 | imm_val_r; // ori
            6'b010010: result = src1 & imm_val_r; // andi

            // Branch operations
            6'b011011: result = (src1 == src2) ? 1 : 0; // beq
            6'b011100: result = (src1 != src2) ? 1 : 0; // bne
            6'b011111: result = (src2 >= src1) ? 1 : 0; // bge
            6'b100000: result = (src1 < src2) ? 1 : 0;  // blt

            default: result = 0;
        endcase
    end

endmodule
